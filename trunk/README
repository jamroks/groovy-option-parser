=Groovy Option Parser=

GOP is a command line option parsing alternative to !CliBuilder.

I wrote GOP for a couple reasons:
 * Needed a small project to learn groovy
 * Replicate the option parsing behaviour of the excellent Ruby library, [http://github.com/alexvollmer/clip/tree/master. clip].  Clip makes it simple to define options and simple to use the parsed parameters.

==An example is the easiest explanation==
{{{
 def parser = new org.computoring.gop.Parser(description: "An example parser.")
 parser.with {
   // support for required options
   required 'f', 'foo-bar', [description: 'A required option with a short name, a long name, and a description'] 

   // support for optional options
   optional 'b', [
     longName: 'bar-baz',   // longName can be specified this way also
     default: 'xyz', 
     description: 'An optional option with a short name, a long name, a default value, and a description'
   ]

   // support for flag (boolean) options
   flag 'c' // a flag option without a long name or a description, flags default to false
   flag 'd', 'debug', [default: true]  // a flag option with a default value of true

   // option short names are not required
   optional null, 'long-opt', [ description: 'An optional option without a shortname.' ]

   // support for parameter validation.  The parameter is passed to the validation closure.  The value
   // returned from the closure is assigned back to the option.
   required 'i', 'count', [
     description: 'A required, validated option', 
     validate: {
       Integer.parseInt it  // the value of the parsed option with be an Integer in this case
     }
   ] 

   // support for remainder validation.  In this case a command is required after parameters.  The remainder is
   // available after parsing as parser.remainder
   remainder {
     if(!it) throw new IllegalArgumentException("missing command")
     it
   }
 }

 // typically, I'll call parse like this.  If anything blows up I catch Exception and 
 // print the parser.usage to stderr and exit
 try {
   def params = parser.parse("-f foo_value --debug --count 123 -- some other stuff".split())
   assert params.'foo-bar' == 'foo_value'
   assert params.b == 'xyz'
   assert params.c == false
   assert params.debug == true
   assert params.count instanceof Integer
   assert params.i == 123
   assert parser.remainder.join(' ') == 'some other stuff'
 }
 catch( Exception e ) {
   System.err << parser.usage
   System.exit(1)
 }
}}}
                         
The example above will generate usage output like this
{{{
An example parser.
Required
  -f, --foo-bar              A required option with a short name, a long name, and a description
  -i, --count                A required, validated option

Optional
  -b, --bar-baz     [xyz]    An optional option with a short name, a long name, a default value, and a description
      --long-opt             An optional option without a shortname.

Flags
  -c                [false]  
  -d, --debug       [true]   
}}}

--------------------------------------------------------------------------------

==A couple interesting features==
 * Flag and optional options can have default values
 * Options can specify a validation closure that parsed values are passed through
 * remaining parameters after parsing can be validated
 * Formatted usage statement is created for you.

*Drop me a note at travis@computoring.org if it's working for you or if it isn't.*

 * Homepage:      http://code.google.com/p/groovy-option-parser/
 * Downloads:     http://code.google.com/p/groovy-option-parser/downloads/list
 * Issue tracker: http://code.google.com/p/groovy-option-parser/issues/list

